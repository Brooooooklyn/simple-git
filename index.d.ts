/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/** An enumeration of all possible kinds of references. */
export const enum ReferenceType {
  /** A reference which points at an object id. */
  Direct = 0,
  /** A reference which points at another reference. */
  Symbolic = 1,
  Unknown = 2
}
/** An enumeration of the possible directions for a remote. */
export const enum Direction {
  /** Data will be fetched (read) from this remote. */
  Fetch = 0,
  /** Data will be pushed (written) to this remote. */
  Push = 1
}
export interface Progress {
  totalObjects: number
  indexedObjects: number
  receivedObjects: number
  localObjects: number
  totalDeltas: number
  indexedDeltas: number
  receivedBytes: number
}
export const enum RepositoryState {
  Clean = 0,
  Merge = 1,
  Revert = 2,
  RevertSequence = 3,
  CherryPick = 4,
  CherryPickSequence = 5,
  Bisect = 6,
  Rebase = 7,
  RebaseInteractive = 8,
  RebaseMerge = 9,
  ApplyMailbox = 10,
  ApplyMailboxOrRebase = 11
}
export const enum RepositoryOpenFlags {
  /** Only open the specified path; don't walk upward searching. */
  NoSearch = 0,
  /** Search across filesystem boundaries. */
  CrossFS = 1,
  /** Force opening as bare repository, and defer loading its config. */
  Bare = 2,
  /** Don't try appending `/.git` to the specified repository path. */
  NoDotGit = 3,
  /** Respect environment variables like `$GIT_DIR`. */
  FromEnv = 4
}
export class Reference {
  /**
   * Ensure the reference name is well-formed.
   *
   * Validation is performed as if [`ReferenceFormat::ALLOW_ONELEVEL`]
   * was given to [`Reference.normalize_name`]. No normalization is
   * performed, however.
   *
   * ```ts
   * import { Reference } from '@napi-rs/simple-git'
   *
   * console.assert(Reference.is_valid_name("HEAD"));
   * console.assert(Reference.is_valid_name("refs/heads/main"));
   *
   * // But:
   * console.assert(!Reference.is_valid_name("main"));
   * console.assert(!Reference.is_valid_name("refs/heads/*"));
   * console.assert(!Reference.is_valid_name("foo//bar"));
   * ```
   */
  static isValidName(name: string): boolean
  /** Check if a reference is a local branch. */
  isBranch(): boolean
  /** Check if a reference is a note. */
  isNote(): boolean
  /** Check if a reference is a remote tracking branch */
  isRemote(): boolean
  /** Check if a reference is a tag */
  isTag(): boolean
  kind(): ReferenceType
  /**
   * Get the full name of a reference.
   *
   * Returns `None` if the name is not valid utf-8.
   */
  name(): string | undefined | null
  /**
   * Get the full shorthand of a reference.
   *
   * This will transform the reference name into a name "human-readable"
   * version. If no shortname is appropriate, it will return the full name.
   *
   * Returns `None` if the shorthand is not valid utf-8.
   */
  shorthand(): string | undefined | null
  /**
   * Get the OID pointed to by a direct reference.
   *
   * Only available if the reference is direct (i.e. an object id reference,
   * not a symbolic one).
   */
  target(): string | undefined | null
  /**
   * Return the peeled OID target of this reference.
   *
   * This peeled OID only applies to direct references that point to a hard
   * Tag object: it is the result of peeling such Tag.
   */
  targetPeel(): string | undefined | null
  /**
   * Get full name to the reference pointed to by a symbolic reference.
   *
   * May return `None` if the reference is either not symbolic or not a
   * valid utf-8 string.
   */
  symbolicTarget(): string | undefined | null
  /**
   * Resolve a symbolic reference to a direct reference.
   *
   * This method iteratively peels a symbolic reference until it resolves to
   * a direct reference to an OID.
   *
   * If a direct reference is passed as an argument, a copy of that
   * reference is returned.
   */
  resolve(): Reference
  /**
   * Rename an existing reference.
   *
   * This method works for both direct and symbolic references.
   *
   * If the force flag is not enabled, and there's already a reference with
   * the given name, the renaming will fail.
   */
  rename(newName: string, force: boolean, msg: string): Reference
}
export class Remote {
  /** Ensure the remote name is well-formed. */
  static isValidName(name: string): boolean
  /**
   * Get the remote's name.
   *
   * Returns `None` if this remote has not yet been named or if the name is
   * not valid utf-8
   */
  name(): string | undefined | null
  /**
   * Get the remote's url.
   *
   * Returns `None` if the url is not valid utf-8
   */
  url(): string | undefined | null
  /**
   * Get the remote's pushurl.
   *
   * Returns `None` if the pushurl is not valid utf-8
   */
  pushurl(): string | undefined | null
  /**
   * Get the remote's default branch.
   *
   * The remote (or more exactly its transport) must have connected to the
   * remote repository. This default branch is available as soon as the
   * connection to the remote is initiated and it remains available after
   * disconnecting.
   */
  defaultBranch(): string
  /** Open a connection to a remote. */
  connect(dir: Direction): void
  /** Check whether the remote is connected */
  connected(): boolean
  /** Disconnect from the remote */
  disconnect(): void
  /**
   * Cancel the operation
   *
   * At certain points in its operation, the network code checks whether the
   * operation has been cancelled and if so stops the operation.
   */
  stop(): void
  fetch(refspecs: string[], cb?: (progress: Progress) => void): void
}
export class RemoteCallbacks {
  constructor()
  transferProgress(callback: (...args: any[]) => any): void
  pushTransferProgress(callback: (a: number, b: number, c: number) => void): void
}
export class FetchOptions {
  constructor()
  remoteCallback(callback: RemoteCallbacks): void
}
export class Repository {
  static init(p: string): Repository
  /**
   * Find and open an existing repository, with additional options.
   *
   * If flags contains REPOSITORY_OPEN_NO_SEARCH, the path must point
   * directly to a repository; otherwise, this may point to a subdirectory
   * of a repository, and `open_ext` will search up through parent
   * directories.
   *
   * If flags contains REPOSITORY_OPEN_CROSS_FS, the search through parent
   * directories will not cross a filesystem boundary (detected when the
   * stat st_dev field changes).
   *
   * If flags contains REPOSITORY_OPEN_BARE, force opening the repository as
   * bare even if it isn't, ignoring any working directory, and defer
   * loading the repository configuration for performance.
   *
   * If flags contains REPOSITORY_OPEN_NO_DOTGIT, don't try appending
   * `/.git` to `path`.
   *
   * If flags contains REPOSITORY_OPEN_FROM_ENV, `open_ext` will ignore
   * other flags and `ceiling_dirs`, and respect the same environment
   * variables git does. Note, however, that `path` overrides `$GIT_DIR`; to
   * respect `$GIT_DIR` as well, use `open_from_env`.
   *
   * ceiling_dirs specifies a list of paths that the search through parent
   * directories will stop before entering.  Use the functions in std::env
   * to construct or manipulate such a path list.
   */
  static openExt(path: string, flags: RepositoryOpenFlags, ceilingDirs: Array<string>): Repository
  /**
   * Attempt to open an already-existing repository at or above `path`
   *
   * This starts at `path` and looks up the filesystem hierarchy
   * until it finds a repository.
   */
  static discover(path: string): Repository
  constructor(gitDir: string)
  /** Retrieve and resolve the reference pointed at by HEAD. */
  head(): Reference
  isShallow(): boolean
  isEmpty(): boolean
  isWorktree(): boolean
  /**
   * Returns the path to the `.git` folder for normal repositories or the
   * repository itself for bare repositories.
   */
  path(): string
  /** Returns the current state of this repository */
  state(): RepositoryState
  /**
   * Get the path of the working directory for this repository.
   *
   * If this repository is bare, then `None` is returned.
   */
  workdir(): string | undefined | null
  /**
   * Set the path to the working directory for this repository.
   *
   * If `update_link` is true, create/update the gitlink file in the workdir
   * and set config "core.worktree" (if workdir is not the parent of the .git
   * directory).
   */
  setWorkdir(path: string, updateGitlink: boolean): void
  /**
   * Get the currently active namespace for this repository.
   *
   * If there is no namespace, or the namespace is not a valid utf8 string,
   * `None` is returned.
   */
  namespace(): string | undefined | null
  /** Set the active namespace for this repository. */
  setNamespace(namespace: string): void
  /** Remove the active namespace for this repository. */
  removeNamespace(): void
  /**
   * Retrieves the Git merge message.
   * Remember to remove the message when finished.
   */
  message(): string
  /** Remove the Git merge message. */
  removeMessage(): void
  /** List all remotes for a given repository */
  remotes(): Array<string>
  /** Get the information for a particular remote */
  remote(name: string): Remote
  getFileLatestModifiedDate(filepath: string): number
  getFileLatestModifiedDateAsync(filepath: string, signal?: AbortSignal | undefined | null): Promise<number>
}
