/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum DiffFlags {
  /**
   * File(s) treated as binary data.
   * 1 << 0
   */
  Binary = 1,
  /**
   * File(s) treated as text data.
   * 1 << 1
   */
  NotBinary = 2,
  /**
   * `id` value is known correct.
   * 1 << 2
   */
  ValidId = 4,
  /**
   * File exists at this side of the delta.
   * 1 << 3
   */
  Exists = 8
}
/** Valid modes for index and tree entries. */
export const enum FileMode {
  /** Unreadable */
  Unreadable = 0,
  /** Tree */
  Tree = 1,
  /** Blob */
  Blob = 2,
  /** Group writable blob. Obsolete mode kept for compatibility reasons */
  BlobGroupWritable = 3,
  /** Blob executable */
  BlobExecutable = 4,
  /** Link */
  Link = 5,
  /** Commit */
  Commit = 6
}
export const enum Delta {
  /** No changes */
  Unmodified = 0,
  /** Entry does not exist in old version */
  Added = 1,
  /** Entry does not exist in new version */
  Deleted = 2,
  /** Entry content changed between old and new */
  Modified = 3,
  /** Entry was renamed between old and new */
  Renamed = 4,
  /** Entry was copied from another old entry */
  Copied = 5,
  /** Entry is ignored item in workdir */
  Ignored = 6,
  /** Entry is untracked item in workdir */
  Untracked = 7,
  /** Type of entry changed between old and new */
  Typechange = 8,
  /** Entry is unreadable */
  Unreadable = 9,
  /** Entry in the index is conflicted */
  Conflicted = 10
}
export interface DiffOptions {
  /**
   * When generating output, include the names of unmodified files if they
   * are included in the `Diff`. Normally these are skipped in the formats
   * that list files (e.g. name-only, name-status, raw). Even with this these
   * will not be included in the patch format.
   */
  showUnmodified?: boolean
}
export const enum ObjectType {
  /** Any kind of git object */
  Any = 0,
  /** An object which corresponds to a git commit */
  Commit = 1,
  /** An object which corresponds to a git tree */
  Tree = 2,
  /** An object which corresponds to a git blob */
  Blob = 3,
  /** An object which corresponds to a git tag */
  Tag = 4
}
/** An enumeration of all possible kinds of references. */
export const enum ReferenceType {
  /** A reference which points at an object id. */
  Direct = 0,
  /** A reference which points at another reference. */
  Symbolic = 1,
  Unknown = 2
}
/** An enumeration of the possible directions for a remote. */
export const enum Direction {
  /** Data will be fetched (read) from this remote. */
  Fetch = 0,
  /** Data will be pushed (written) to this remote. */
  Push = 1
}
/** Configuration for how pruning is done on a fetch */
export const enum FetchPrune {
  /** Use the setting from the configuration */
  Unspecified = 0,
  /** Force pruning on */
  On = 1,
  /** Force pruning off */
  Off = 2
}
/** Automatic tag following options. */
export const enum AutotagOption {
  /** Use the setting from the remote's configuration */
  Unspecified = 0,
  /** Ask the server for tags pointing to objects we're already downloading */
  Auto = 1,
  /** Don't ask for any tags beyond the refspecs */
  None = 2,
  /** Ask for all the tags */
  All = 3
}
/**
 * Remote redirection settings; whether redirects to another host are
 * permitted.
 *
 * By default, git will follow a redirect on the initial request
 * (`/info/refs`), but not subsequent requests.
 */
export const enum RemoteRedirect {
  /** Do not follow any off-site redirects at any stage of the fetch or push. */
  None = 0,
  /**
   * Allow off-site redirects only upon the initial request. This is the
   * default.
   */
  Initial = 1,
  /** Allow redirects at any stage in the fetch or push. */
  All = 2
}
/** Types of credentials that can be requested by a credential callback. */
export const enum CredentialType {
  /** 1 << 0 */
  UserPassPlaintext = 1,
  /** 1 << 1 */
  SshKey = 2,
  /** 1 << 6 */
  SshMemory = 64,
  /** 1 << 2 */
  SshCustom = 4,
  /** 1 << 3 */
  Default = 8,
  /** 1 << 4 */
  SshInteractive = 16,
  /** 1 << 5 */
  Username = 32
}
export interface CredInfo {
  credType: CredentialType
  url: string
  username: string
}
export interface Progress {
  totalObjects: number
  indexedObjects: number
  receivedObjects: number
  localObjects: number
  totalDeltas: number
  indexedDeltas: number
  receivedBytes: number
}
export interface PushTransferProgress {
  current: number
  total: number
  bytes: number
}
/** Check whether a cred_type contains another credential type. */
export function credTypeContains(credType: CredentialType, another: CredentialType): boolean
export const enum RepositoryState {
  Clean = 0,
  Merge = 1,
  Revert = 2,
  RevertSequence = 3,
  CherryPick = 4,
  CherryPickSequence = 5,
  Bisect = 6,
  Rebase = 7,
  RebaseInteractive = 8,
  RebaseMerge = 9,
  ApplyMailbox = 10,
  ApplyMailboxOrRebase = 11
}
export const enum RepositoryOpenFlags {
  /** Only open the specified path; don't walk upward searching. */
  NoSearch = 0,
  /** Search across filesystem boundaries. */
  CrossFS = 1,
  /** Force opening as bare repository, and defer loading its config. */
  Bare = 2,
  /** Don't try appending `/.git` to the specified repository path. */
  NoDotGit = 3,
  /** Respect environment variables like `$GIT_DIR`. */
  FromEnv = 4
}
export const enum CloneLocal {
  /**
   * Auto-detect (default)
   *
   * Here libgit2 will bypass the git-aware transport for local paths, but
   * use a normal fetch for `file://` URLs.
   */
  Auto = 0,
  /** Bypass the git-aware transport even for `file://` URLs. */
  Local = 1,
  /** Never bypass the git-aware transport */
  None = 2,
  /** Bypass the git-aware transport, but don't try to use hardlinks. */
  NoLinks = 3
}
/** Orderings that may be specified for Revwalk iteration. */
export const enum Sort {
  /**
   * Sort the repository contents in no particular ordering.
   *
   * This sorting is arbitrary, implementation-specific, and subject to
   * change at any time. This is the default sorting for new walkers.
   */
  None = 0,
  /**
   * Sort the repository contents in topological order (children before
   * parents).
   *
   * This sorting mode can be combined with time sorting.
   * 1 << 0
   */
  Topological = 1,
  /**
   * Sort the repository contents by commit time.
   *
   * This sorting mode can be combined with topological sorting.
   * 1 << 1
   */
  Time = 2,
  /**
   * Iterate through the repository contents in reverse order.
   *
   * This sorting mode can be combined with any others.
   * 1 << 2
   */
  Reverse = 4
}
export class Commit {
  /** Get the id (SHA1) of a repository object */
  id(): string
  /**
   * Get the id of the tree pointed to by this commit.
   *
   * No attempts are made to fetch an object from the ODB.
   */
  treeId(): string
  /** Get the tree pointed to by this commit. */
  tree(): Tree
  /**
   *
   * The returned message will be slightly prettified by removing any
   * potential leading newlines.
   *
   * `None` will be returned if the message is not valid utf-8
   */
  message(): string | null
  /**
   * Get the full message of a commit as a byte slice.
   *
   * The returned message will be slightly prettified by removing any
   * potential leading newlines.
   */
  messageBytes(): Buffer
  /**
   * Get the encoding for the message of a commit, as a string representing a
   * standard encoding name.
   *
   * `None` will be returned if the encoding is not known
   */
  messageEncoding(): string | null
  /**
   * Get the full raw message of a commit.
   *
   * `None` will be returned if the message is not valid utf-8
   */
  messageRaw(): string | null
  /** Get the full raw message of a commit. */
  messageRawBytes(): Buffer
  /**
   * Get the full raw text of the commit header.
   *
   * `None` will be returned if the message is not valid utf-8
   */
  rawHeader(): string | null
  /** Get an arbitrary header field. */
  headerFieldBytes(field: string): Buffer
  /** Get the full raw text of the commit header. */
  rawHeaderBytes(): Buffer
  /**
   * Get the short "summary" of the git commit message.
   *
   * The returned message is the summary of the commit, comprising the first
   * paragraph of the message with whitespace trimmed and squashed.
   *
   * `None` may be returned if an error occurs or if the summary is not valid
   * utf-8.
   */
  summary(): string | null
  /**
   * Get the short "summary" of the git commit message.
   *
   * The returned message is the summary of the commit, comprising the first
   * paragraph of the message with whitespace trimmed and squashed.
   *
   * `None` may be returned if an error occurs
   */
  summaryBytes(): Buffer | null
  /**
   * Get the long "body" of the git commit message.
   *
   * The returned message is the body of the commit, comprising everything
   * but the first paragraph of the message. Leading and trailing whitespaces
   * are trimmed.
   *
   * `None` may be returned if an error occurs or if the summary is not valid
   * utf-8.
   */
  body(): string | null
  /**
   * Get the long "body" of the git commit message.
   *
   * The returned message is the body of the commit, comprising everything
   * but the first paragraph of the message. Leading and trailing whitespaces
   * are trimmed.
   *
   * `None` may be returned if an error occurs.
   */
  bodyBytes(): Buffer | null
  /**
   * Get the commit time (i.e. committer time) of a commit.
   *
   * The first element of the tuple is the time, in seconds, since the epoch.
   * The second element is the offset, in minutes, of the time zone of the
   * committer's preferred time zone.
   */
  time(): Date
  /** Get the author of this commit. */
  author(): Signature
  /** Get the committer of this commit. */
  committer(): Signature
  /**
   * Get the number of parents of this commit.
   *
   * Use the `parents` iterator to return an iterator over all parents.
   */
  parentCount(): bigint
}
/** An iterator over the diffs in a delta */
export class Deltas {
  [Symbol.iterator](): Iterator<DiffDelta, void, void>
}
export class DiffDelta {
  /**
   * Returns the flags on the delta.
   *
   * For more information, see `DiffFlags`'s documentation.
   */
  flags(): DiffFlags
  /** Returns the number of files in this delta. */
  numFiles(): number
  /** Returns the status of this entry */
  status(): Delta
  /**
   * Return the file which represents the "from" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   */
  oldFile(): DiffFile
  /**
   * Return the file which represents the "to" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   */
  newFile(): DiffFile
}
export class DiffFile {
  /**
   * Returns the Oid of this item.
   *
   * If this entry represents an absent side of a diff (e.g. the `old_file`
   * of a `Added` delta), then the oid returned will be zeroes.
   */
  id(): string
  /**
   * Returns the path, in bytes, of the entry relative to the working
   * directory of the repository.
   */
  path(): string | null
  /** Returns the size of this entry, in bytes */
  size(): bigint
  /** Returns `true` if file(s) are treated as binary data. */
  isBinary(): boolean
  /** Returns `true` if file(s) are treated as text data. */
  isNotBinary(): boolean
  /** Returns `true` if `id` value is known correct. */
  isValidId(): boolean
  /** Returns `true` if file exists at this side of the delta. */
  exists(): boolean
  /** Returns file mode. */
  mode(): FileMode
}
export class Diff {
  /**
   * Merge one diff into another.
   *
   * This merges items from the "from" list into the "self" list.  The
   * resulting diff will have all items that appear in either list.
   * If an item appears in both lists, then it will be "merged" to appear
   * as if the old version was from the "onto" list and the new version
   * is from the "from" list (with the exception that if the item has a
   * pending DELETE in the middle, then it will show as deleted).
   */
  merge(diff: Diff): void
  /** Returns an iterator over the deltas in this diff. */
  deltas(): Deltas
  /** Check if deltas are sorted case sensitively or insensitively. */
  isSortedIcase(): boolean
}
export class GitObject {
  /** Get the id (SHA1) of a repository object */
  id(): string
  /** Get the type of the object. */
  kind(): ObjectType | null
  peel(kind: ObjectType): GitObject
}
export class Reference {
  /**
   * Ensure the reference name is well-formed.
   *
   * Validation is performed as if [`ReferenceFormat::ALLOW_ONELEVEL`]
   * was given to [`Reference.normalize_name`]. No normalization is
   * performed, however.
   *
   * ```ts
   * import { Reference } from '@napi-rs/simple-git'
   *
   * console.assert(Reference.is_valid_name("HEAD"));
   * console.assert(Reference.is_valid_name("refs/heads/main"));
   *
   * // But:
   * console.assert(!Reference.is_valid_name("main"));
   * console.assert(!Reference.is_valid_name("refs/heads/*"));
   * console.assert(!Reference.is_valid_name("foo//bar"));
   * ```
   */
  static isValidName(name: string): boolean
  /** Check if a reference is a local branch. */
  isBranch(): boolean
  /** Check if a reference is a note. */
  isNote(): boolean
  /** Check if a reference is a remote tracking branch */
  isRemote(): boolean
  /** Check if a reference is a tag */
  isTag(): boolean
  kind(): ReferenceType
  /**
   * Get the full name of a reference.
   *
   * Returns `None` if the name is not valid utf-8.
   */
  name(): string | null
  /**
   * Get the full shorthand of a reference.
   *
   * This will transform the reference name into a name "human-readable"
   * version. If no shortname is appropriate, it will return the full name.
   *
   * Returns `None` if the shorthand is not valid utf-8.
   */
  shorthand(): string | null
  /**
   * Get the OID pointed to by a direct reference.
   *
   * Only available if the reference is direct (i.e. an object id reference,
   * not a symbolic one).
   */
  target(): string | null
  /**
   * Return the peeled OID target of this reference.
   *
   * This peeled OID only applies to direct references that point to a hard
   * Tag object: it is the result of peeling such Tag.
   */
  targetPeel(): string | null
  /**
   * Peel a reference to a tree
   *
   * This method recursively peels the reference until it reaches
   * a tree.
   */
  peelToTree(): Tree
  /**
   * Get full name to the reference pointed to by a symbolic reference.
   *
   * May return `None` if the reference is either not symbolic or not a
   * valid utf-8 string.
   */
  symbolicTarget(): string | null
  /**
   * Resolve a symbolic reference to a direct reference.
   *
   * This method iteratively peels a symbolic reference until it resolves to
   * a direct reference to an OID.
   *
   * If a direct reference is passed as an argument, a copy of that
   * reference is returned.
   */
  resolve(): Reference
  /**
   * Rename an existing reference.
   *
   * This method works for both direct and symbolic references.
   *
   * If the force flag is not enabled, and there's already a reference with
   * the given name, the renaming will fail.
   */
  rename(newName: string, force: boolean, msg: string): Reference
}
export class Remote {
  /** Ensure the remote name is well-formed. */
  static isValidName(name: string): boolean
  /**
   * Get the remote's name.
   *
   * Returns `None` if this remote has not yet been named or if the name is
   * not valid utf-8
   */
  name(): string | null
  /**
   * Get the remote's url.
   *
   * Returns `None` if the url is not valid utf-8
   */
  url(): string | null
  /**
   * Get the remote's pushurl.
   *
   * Returns `None` if the pushurl is not valid utf-8
   */
  pushurl(): string | null
  /**
   * Get the remote's default branch.
   *
   * The remote (or more exactly its transport) must have connected to the
   * remote repository. This default branch is available as soon as the
   * connection to the remote is initiated and it remains available after
   * disconnecting.
   */
  defaultBranch(): string
  /** Open a connection to a remote. */
  connect(dir: Direction): void
  /** Check whether the remote is connected */
  connected(): boolean
  /** Disconnect from the remote */
  disconnect(): void
  /**
   * Cancel the operation
   *
   * At certain points in its operation, the network code checks whether the
   * operation has been cancelled and if so stops the operation.
   */
  stop(): void
  /**
   * Download new data and update tips
   *
   * Convenience function to connect to a remote, download the data,
   * disconnect and update the remote-tracking branches.
   *
   */
  fetch(refspecs: Array<string>, fetchOptions?: FetchOptions | undefined | null): void
  /** Update the tips to the new state */
  updateTips(updateFetchhead: boolean, downloadTags: AutotagOption, callbacks?: RemoteCallbacks | undefined | null, msg?: string | undefined | null): void
}
export class RemoteCallbacks {
  constructor()
  /**
   * The callback through which to fetch credentials if required.
   *
   * # Example
   *
   * Prepare a callback to authenticate using the `$HOME/.ssh/id_rsa` SSH key, and
   * extracting the username from the URL (i.e. git@github.com:rust-lang/git2-rs.git):
   *
   * ```js
   * import { join } from 'node:path'
   * import { homedir } from 'node:os'
   *
   * import { Cred, FetchOptions, RemoteCallbacks, RepoBuilder, credTypeContains } from '@napi-rs/simple-git'
   *
   * const builder = new RepoBuilder()
   * const remoteCallbacks = new RemoteCallbacks()
   * .credentials((cred) => {
   *   return Cred.sshKey(cred.username, null, join(homedir(), '.ssh', 'id_rsa'), null)
   * })
   *
   * const fetchOptions = new FetchOptions().depth(0).remoteCallback(remoteCallbacks)
   *
   * const repo = builder.branch('master')
   *  .fetchOptions(fetchOptions)
   *  .clone("git@github.com:rust-lang/git2-rs.git", "git2-rs")
   * ```
   */
  credentials(callback: (arg: CredInfo) => Cred): this
  /** The callback through which progress is monitored. */
  transferProgress(callback: (arg: Progress) => void): this
  /** The callback through which progress of push transfer is monitored */
  pushTransferProgress(callback: (current: number, total: number, bytes: number) => void): this
}
export class FetchOptions {
  constructor()
  /** Set the callbacks to use for the fetch operation. */
  remoteCallback(callback: RemoteCallbacks): this
  /** Set the proxy options to use for the fetch operation. */
  proxyOptions(options: ProxyOptions): this
  /** Set whether to perform a prune after the fetch. */
  prune(prune: FetchPrune): this
  /**
   * Set whether to write the results to FETCH_HEAD.
   *
   * Defaults to `true`.
   */
  updateFetchhead(update: boolean): this
  /**
   * Set fetch depth, a value less or equal to 0 is interpreted as pull
   * everything (effectively the same as not declaring a limit depth).
   */
  depth(depth: number): this
  /**
   * Set how to behave regarding tags on the remote, such as auto-downloading
   * tags for objects we're downloading or downloading all of them.
   *
   * The default is to auto-follow tags.
   */
  downloadTags(opt: AutotagOption): this
  /**
   * Set remote redirection settings; whether redirects to another host are
   * permitted.
   *
   * By default, git will follow a redirect on the initial request
   * (`/info/refs`), but not subsequent requests.
   */
  followRedirects(opt: RemoteRedirect): this
  /** Set extra headers for this fetch operation. */
  customHeaders(headers: Array<string>): this
}
export class ProxyOptions {
  constructor()
  /**
   * Try to auto-detect the proxy from the git configuration.
   *
   * Note that this will override `url` specified before.
   */
  auto(): this
  /**
   * Specify the exact URL of the proxy to use.
   *
   * Note that this will override `auto` specified before.
   */
  url(url: string): this
}
export class Cred {
  /**
   * Create a "default" credential usable for Negotiate mechanisms like NTLM
   * or Kerberos authentication.
   */
  constructor()
  /**
   * Create a new ssh key credential object used for querying an ssh-agent.
   *
   * The username specified is the username to authenticate.
   */
  static sshKeyFromAgent(username: string): Cred
  /** Create a new passphrase-protected ssh key credential object. */
  static sshKey(username: string, publickey: string | undefined | null, privatekey: string, passphrase?: string | undefined | null): Cred
  /** Create a new ssh key credential object reading the keys from memory. */
  static sshKeyFromMemory(username: string, publickey: string | undefined | null, privatekey: string, passphrase?: string | undefined | null): Cred
  /** Create a new plain-text username and password credential object. */
  static userpassPlaintext(username: string, password: string): Cred
  /**
   * Create a credential to specify a username.
   *
   * This is used with ssh authentication to query for the username if none is
   * specified in the URL.
   */
  static username(username: string): Cred
  /** Check whether a credential object contains username information. */
  hasUsername(): boolean
  /** Return the type of credentials that this object represents. */
  credtype(): CredentialType
}
export class Repository {
  static init(p: string): Repository
  /**
   * Find and open an existing repository, with additional options.
   *
   * If flags contains REPOSITORY_OPEN_NO_SEARCH, the path must point
   * directly to a repository; otherwise, this may point to a subdirectory
   * of a repository, and `open_ext` will search up through parent
   * directories.
   *
   * If flags contains REPOSITORY_OPEN_CROSS_FS, the search through parent
   * directories will not cross a filesystem boundary (detected when the
   * stat st_dev field changes).
   *
   * If flags contains REPOSITORY_OPEN_BARE, force opening the repository as
   * bare even if it isn't, ignoring any working directory, and defer
   * loading the repository configuration for performance.
   *
   * If flags contains REPOSITORY_OPEN_NO_DOTGIT, don't try appending
   * `/.git` to `path`.
   *
   * If flags contains REPOSITORY_OPEN_FROM_ENV, `open_ext` will ignore
   * other flags and `ceiling_dirs`, and respect the same environment
   * variables git does. Note, however, that `path` overrides `$GIT_DIR`; to
   * respect `$GIT_DIR` as well, use `open_from_env`.
   *
   * ceiling_dirs specifies a list of paths that the search through parent
   * directories will stop before entering.  Use the functions in std::env
   * to construct or manipulate such a path list.
   */
  static openExt(path: string, flags: RepositoryOpenFlags, ceilingDirs: Array<string>): Repository
  /**
   * Attempt to open an already-existing repository at or above `path`
   *
   * This starts at `path` and looks up the filesystem hierarchy
   * until it finds a repository.
   */
  static discover(path: string): Repository
  /**
   * Creates a new `--bare` repository in the specified folder.
   *
   * The folder must exist prior to invoking this function.
   */
  static initBare(path: string): Repository
  /**
   * Clone a remote repository.
   *
   * See the `RepoBuilder` struct for more information. This function will
   * delegate to a fresh `RepoBuilder`
   */
  static clone(url: string, path: string): Repository
  /**
   * Clone a remote repository, initialize and update its submodules
   * recursively.
   *
   * This is similar to `git clone --recursive`.
   */
  static cloneRecurse(url: string, path: string): Repository
  /**
   * Attempt to open an already-existing repository at `path`.
   *
   * The path can point to either a normal or bare repository.
   */
  constructor(gitDir: string)
  /** Retrieve and resolve the reference pointed at by HEAD. */
  head(): Reference
  /** Tests whether this repository is a shallow clone. */
  isShallow(): boolean
  /** Tests whether this repository is empty. */
  isEmpty(): boolean
  /** Tests whether this repository is a worktree. */
  isWorktree(): boolean
  /**
   * Returns the path to the `.git` folder for normal repositories or the
   * repository itself for bare repositories.
   */
  path(): string
  /** Returns the current state of this repository */
  state(): RepositoryState
  /**
   * Get the path of the working directory for this repository.
   *
   * If this repository is bare, then `None` is returned.
   */
  workdir(): string | null
  /**
   * Set the path to the working directory for this repository.
   *
   * If `update_link` is true, create/update the gitlink file in the workdir
   * and set config "core.worktree" (if workdir is not the parent of the .git
   * directory).
   */
  setWorkdir(path: string, updateGitlink: boolean): void
  /**
   * Get the currently active namespace for this repository.
   *
   * If there is no namespace, or the namespace is not a valid utf8 string,
   * `None` is returned.
   */
  namespace(): string | null
  /** Set the active namespace for this repository. */
  setNamespace(namespace: string): void
  /** Remove the active namespace for this repository. */
  removeNamespace(): void
  /**
   * Retrieves the Git merge message.
   * Remember to remove the message when finished.
   */
  message(): string
  /** Remove the Git merge message. */
  removeMessage(): void
  /** List all remotes for a given repository */
  remotes(): Array<string>
  /** Get the information for a particular remote */
  findRemote(name: string): Remote
  /**
   * Add a remote with the default fetch refspec to the repository's
   * configuration.
   */
  remote(name: string, url: string): Remote
  /**
   * Add a remote with the provided fetch refspec to the repository's
   * configuration.
   */
  remoteWithFetch(name: string, url: string, refspect: string): Remote
  /**
   * Create an anonymous remote
   *
   * Create a remote with the given URL and refspec in memory. You can use
   * this when you have a URL instead of a remote's name. Note that anonymous
   * remotes cannot be converted to persisted remotes.
   */
  remoteAnonymous(url: string): Remote
  /**
   * Give a remote a new name
   *
   * All remote-tracking branches and configuration settings for the remote
   * are updated.
   *
   * A temporary in-memory remote cannot be given a name with this method.
   *
   * No loaded instances of the remote with the old name will change their
   * name or their list of refspecs.
   *
   * The returned array of strings is a list of the non-default refspecs
   * which cannot be renamed and are returned for further processing by the
   * caller.
   */
  remoteRename(name: string, newName: string): Array<string>
  /**
   * Delete an existing persisted remote.
   *
   * All remote-tracking branches and configuration settings for the remote
   * will be removed.
   */
  remoteDelete(name: string): this
  /**
   * Add a fetch refspec to the remote's configuration
   *
   * Add the given refspec to the fetch list in the configuration. No loaded
   */
  remoteAddFetch(name: string, refspec: string): this
  /**
   * Add a push refspec to the remote's configuration.
   *
   * Add the given refspec to the push list in the configuration. No
   * loaded remote instances will be affected.
   */
  remoteAddPush(name: string, refspec: string): this
  /**
   * Add a push refspec to the remote's configuration.
   *
   * Add the given refspec to the push list in the configuration. No
   * loaded remote instances will be affected.
   */
  remoteSetUrl(name: string, url: string): this
  /**
   * Set the remote's URL for pushing in the configuration.
   *
   * Remote objects already in memory will not be affected. This assumes
   * the common case of a single-url remote and will otherwise return an
   * error.
   *
   * `None` indicates that it should be cleared.
   */
  remoteSetPushurl(name: string, url?: string | undefined | null): this
  /** Lookup a reference to one of the objects in a repository. */
  findTree(oid: string): Tree
  findCommit(oid: string): Commit
  /**
   * Create a diff between a tree and the working directory.
   *
   * The tree you provide will be used for the "old_file" side of the delta,
   * and the working directory will be used for the "new_file" side.
   *
   * This is not the same as `git diff <treeish>` or `git diff-index
   * <treeish>`.  Those commands use information from the index, whereas this
   * function strictly returns the differences between the tree and the files
   * in the working directory, regardless of the state of the index.  Use
   * `tree_to_workdir_with_index` to emulate those commands.
   *
   * To see difference between this and `tree_to_workdir_with_index`,
   * consider the example of a staged file deletion where the file has then
   * been put back into the working dir and further modified.  The
   * tree-to-workdir diff for that file is 'modified', but `git diff` would
   * show status 'deleted' since there is a staged delete.
   *
   * If `None` is passed for `tree`, then an empty tree is used.
   */
  diffTreeToWorkdir(oldTree?: Tree | undefined | null): Diff
  /**
   * Create a diff between a tree and the working directory using index data
   * to account for staged deletes, tracked files, etc.
   *
   * This emulates `git diff <tree>` by diffing the tree to the index and
   * the index to the working directory and blending the results into a
   * single diff that includes staged deleted, etc.
   */
  diffTreeToWorkdirWithIndex(oldTree?: Tree | undefined | null): Diff
  treeEntryToObject(treeEntry: TreeEntry): GitObject
  /**
   * Create new commit in the repository
   *
   * If the `update_ref` is not `None`, name of the reference that will be
   * updated to point to this commit. If the reference is not direct, it will
   * be resolved to a direct reference. Use "HEAD" to update the HEAD of the
   * current branch and make it point to this commit. If the reference
   * doesn't exist yet, it will be created. If it does exist, the first
   * parent must be the tip of this branch.
   */
  commit(updateRef: string | undefined | null, author: Signature, committer: Signature, message: string, tree: Tree): string
  /** Create a revwalk that can be used to traverse the commit graph. */
  revWalk(): RevWalk
  getFileLatestModifiedDate(filepath: string): number
  getFileLatestModifiedDateAsync(filepath: string, signal?: AbortSignal | undefined | null): Promise<number>
}
export class RepoBuilder {
  constructor()
  /**
   * Indicate whether the repository will be cloned as a bare repository or
   * not.
   */
  bare(bare: boolean): this
  /**
   * Specify the name of the branch to check out after the clone.
   *
   * If not specified, the remote's default branch will be used.
   */
  branch(branch: string): this
  /**
   * Configures options for bypassing the git-aware transport on clone.
   *
   * Bypassing it means that instead of a fetch libgit2 will copy the object
   * database directory instead of figuring out what it needs, which is
   * faster. If possible, it will hardlink the files to save space.
   */
  cloneLocal(cloneLocal: CloneLocal): this
  /**
   * Options which control the fetch, including callbacks.
   *
   * The callbacks are used for reporting fetch progress, and for acquiring
   * credentials in the event they are needed.
   */
  fetchOptions(fetchOptions: FetchOptions): this
  clone(url: string, path: string): Repository
}
export class RevWalk {
  [Symbol.iterator](): Iterator<string, void, void>
  /**
   * Reset a revwalk to allow re-configuring it.
   *
   * The revwalk is automatically reset when iteration of its commits
   * completes.
   */
  reset(): this
  /** Set the sorting mode for a revwalk. */
  setSorting(sorting: Sort): this
  /**
   * Simplify the history by first-parent
   *
   * No parents other than the first for each commit will be enqueued.
   */
  simplifyFirstParent(): this
  /**
   * Mark a commit to start traversal from.
   *
   * The given OID must belong to a commitish on the walked repository.
   *
   * The given commit will be used as one of the roots when starting the
   * revision walk. At least one commit must be pushed onto the walker before
   * a walk can be started.
   */
  push(oid: string): this
  /**
   * Push the repository's HEAD
   *
   * For more information, see `push`.
   */
  pushHead(): this
  /**
   * Push matching references
   *
   * The OIDs pointed to by the references that match the given glob pattern
   * will be pushed to the revision walker.
   *
   * A leading 'refs/' is implied if not present as well as a trailing `/ \
   * *` if the glob lacks '?', ' \ *' or '['.
   *
   * Any references matching this glob which do not point to a commitish
   * will be ignored.
   */
  pushGlob(glob: string): this
  /**
   * Push and hide the respective endpoints of the given range.
   *
   * The range should be of the form `<commit>..<commit>` where each
   * `<commit>` is in the form accepted by `revparse_single`. The left-hand
   * commit will be hidden and the right-hand commit pushed.
   */
  pushRange(range: string): this
  /**
   * Push the OID pointed to by a reference
   *
   * The reference must point to a commitish.
   */
  pushRef(reference: string): this
  /** Mark a commit as not of interest to this revwalk. */
  hide(oid: string): this
  /**
   * Hide the repository's HEAD
   *
   * For more information, see `hide`.
   */
  hideHead(): this
  /**
   * Hide matching references.
   *
   * The OIDs pointed to by the references that match the given glob pattern
   * and their ancestors will be hidden from the output on the revision walk.
   *
   * A leading 'refs/' is implied if not present as well as a trailing `/ \
   * *` if the glob lacks '?', ' \ *' or '['.
   *
   * Any references matching this glob which do not point to a commitish
   * will be ignored.
   */
  hideGlob(glob: string): this
  /**
   * Hide the OID pointed to by a reference.
   *
   * The reference must point to a commitish.
   */
  hideRef(reference: string): this
}
/**
 * A Signature is used to indicate authorship of various actions throughout the
 * library.
 *
 * Signatures contain a name, email, and timestamp. All fields can be specified
 * with `new` while the `now` constructor omits the timestamp. The
 * [`Repository::signature`] method can be used to create a default signature
 * with name and email values read from the configuration.
 *
 * [`Repository::signature`]: struct.Repository.html#method.signature
 */
export class Signature {
  /**
   * Create a new action signature with a timestamp of 'now'.
   *
   * See `new` for more information
   */
  static now(name: string, email: string): Signature
  /**
   * Create a new action signature.
   *
   * The `time` specified is in seconds since the epoch, and the `offset` is
   * the time zone offset in minutes.
   *
   * Returns error if either `name` or `email` contain angle brackets.
   */
  constructor(name: string, email: string, time: number)
  /**
   * Gets the name on the signature.
   *
   * Returns `None` if the name is not valid utf-8
   */
  name(): string | null
  /**
   * Gets the email on the signature.
   *
   * Returns `None` if the email is not valid utf-8
   */
  email(): string | null
  /** Return the time, in seconds, from epoch */
  when(): number
}
export class Tree {
  /** Get the id (SHA1) of a repository object */
  id(): string
  /** Get the number of entries listed in a tree. */
  len(): bigint
  /** Return `true` if there is not entry */
  isEmpty(): boolean
  /** Returns an iterator over the entries in this tree. */
  iter(): TreeIter
}
export class TreeIter {
  [Symbol.iterator](): Iterator<TreeEntry, void, void>
}
export class TreeEntry {
  /** Get the id of the object pointed by the entry */
  id(): string
  /** Get the name of a tree entry */
  name(): string
  /** Get the filename of a tree entry */
  nameBytes(): Buffer
}
