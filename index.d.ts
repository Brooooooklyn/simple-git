/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum Delta {
  /** No changes */
  Unmodified = 0,
  /** Entry does not exist in old version */
  Added = 1,
  /** Entry does not exist in new version */
  Deleted = 2,
  /** Entry content changed between old and new */
  Modified = 3,
  /** Entry was renamed between old and new */
  Renamed = 4,
  /** Entry was copied from another old entry */
  Copied = 5,
  /** Entry is ignored item in workdir */
  Ignored = 6,
  /** Entry is untracked item in workdir */
  Untracked = 7,
  /** Type of entry changed between old and new */
  Typechange = 8,
  /** Entry is unreadable */
  Unreadable = 9,
  /** Entry in the index is conflicted */
  Conflicted = 10
}
export interface DiffOptions {
  /**
   * When generating output, include the names of unmodified files if they
   * are included in the `Diff`. Normally these are skipped in the formats
   * that list files (e.g. name-only, name-status, raw). Even with this these
   * will not be included in the patch format.
   */
  showUnmodified?: boolean
}
/** An enumeration of all possible kinds of references. */
export const enum ReferenceType {
  /** A reference which points at an object id. */
  Direct = 0,
  /** A reference which points at another reference. */
  Symbolic = 1,
  Unknown = 2
}
/** An enumeration of the possible directions for a remote. */
export const enum Direction {
  /** Data will be fetched (read) from this remote. */
  Fetch = 0,
  /** Data will be pushed (written) to this remote. */
  Push = 1
}
export interface Progress {
  totalObjects: number
  indexedObjects: number
  receivedObjects: number
  localObjects: number
  totalDeltas: number
  indexedDeltas: number
  receivedBytes: number
}
export const enum RepositoryState {
  Clean = 0,
  Merge = 1,
  Revert = 2,
  RevertSequence = 3,
  CherryPick = 4,
  CherryPickSequence = 5,
  Bisect = 6,
  Rebase = 7,
  RebaseInteractive = 8,
  RebaseMerge = 9,
  ApplyMailbox = 10,
  ApplyMailboxOrRebase = 11
}
export const enum RepositoryOpenFlags {
  /** Only open the specified path; don't walk upward searching. */
  NoSearch = 0,
  /** Search across filesystem boundaries. */
  CrossFS = 1,
  /** Force opening as bare repository, and defer loading its config. */
  Bare = 2,
  /** Don't try appending `/.git` to the specified repository path. */
  NoDotGit = 3,
  /** Respect environment variables like `$GIT_DIR`. */
  FromEnv = 4
}
/** An iterator over the diffs in a delta */
export class Deltas {
  [Symbol.iterator](): Iterator<DiffDelta, void, void>
}
export class DiffDelta {
  /** Returns the number of files in this delta. */
  numFiles(): number
  /** Returns the status of this entry */
  status(): Delta
  /**
   * Return the file which represents the "from" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   */
  oldFile(): DiffFile
  /**
   * Return the file which represents the "to" side of the diff.
   *
   * What side this means depends on the function that was used to generate
   * the diff and will be documented on the function itself.
   */
  newFile(): DiffFile
}
export class DiffFile {
  /**
   * Returns the path, in bytes, of the entry relative to the working
   * directory of the repository.
   */
  path(): string | null
}
export class Diff {
  /**
   * Merge one diff into another.
   *
   * This merges items from the "from" list into the "self" list.  The
   * resulting diff will have all items that appear in either list.
   * If an item appears in both lists, then it will be "merged" to appear
   * as if the old version was from the "onto" list and the new version
   * is from the "from" list (with the exception that if the item has a
   * pending DELETE in the middle, then it will show as deleted).
   */
  merge(diff: Diff): void
  /** Returns an iterator over the deltas in this diff. */
  deltas(): Deltas
  /** Check if deltas are sorted case sensitively or insensitively. */
  isSortedIcase(): boolean
}
export class Reference {
  /**
   * Ensure the reference name is well-formed.
   *
   * Validation is performed as if [`ReferenceFormat::ALLOW_ONELEVEL`]
   * was given to [`Reference.normalize_name`]. No normalization is
   * performed, however.
   *
   * ```ts
   * import { Reference } from '@napi-rs/simple-git'
   *
   * console.assert(Reference.is_valid_name("HEAD"));
   * console.assert(Reference.is_valid_name("refs/heads/main"));
   *
   * // But:
   * console.assert(!Reference.is_valid_name("main"));
   * console.assert(!Reference.is_valid_name("refs/heads/*"));
   * console.assert(!Reference.is_valid_name("foo//bar"));
   * ```
   */
  static isValidName(name: string): boolean
  /** Check if a reference is a local branch. */
  isBranch(): boolean
  /** Check if a reference is a note. */
  isNote(): boolean
  /** Check if a reference is a remote tracking branch */
  isRemote(): boolean
  /** Check if a reference is a tag */
  isTag(): boolean
  kind(): ReferenceType
  /**
   * Get the full name of a reference.
   *
   * Returns `None` if the name is not valid utf-8.
   */
  name(): string | null
  /**
   * Get the full shorthand of a reference.
   *
   * This will transform the reference name into a name "human-readable"
   * version. If no shortname is appropriate, it will return the full name.
   *
   * Returns `None` if the shorthand is not valid utf-8.
   */
  shorthand(): string | null
  /**
   * Get the OID pointed to by a direct reference.
   *
   * Only available if the reference is direct (i.e. an object id reference,
   * not a symbolic one).
   */
  target(): string | null
  /**
   * Return the peeled OID target of this reference.
   *
   * This peeled OID only applies to direct references that point to a hard
   * Tag object: it is the result of peeling such Tag.
   */
  targetPeel(): string | null
  /**
   * Peel a reference to a tree
   *
   * This method recursively peels the reference until it reaches
   * a tree.
   */
  peelToTree(): Tree
  /**
   * Get full name to the reference pointed to by a symbolic reference.
   *
   * May return `None` if the reference is either not symbolic or not a
   * valid utf-8 string.
   */
  symbolicTarget(): string | null
  /**
   * Resolve a symbolic reference to a direct reference.
   *
   * This method iteratively peels a symbolic reference until it resolves to
   * a direct reference to an OID.
   *
   * If a direct reference is passed as an argument, a copy of that
   * reference is returned.
   */
  resolve(): Reference
  /**
   * Rename an existing reference.
   *
   * This method works for both direct and symbolic references.
   *
   * If the force flag is not enabled, and there's already a reference with
   * the given name, the renaming will fail.
   */
  rename(newName: string, force: boolean, msg: string): Reference
}
export class Remote {
  /** Ensure the remote name is well-formed. */
  static isValidName(name: string): boolean
  /**
   * Get the remote's name.
   *
   * Returns `None` if this remote has not yet been named or if the name is
   * not valid utf-8
   */
  name(): string | null
  /**
   * Get the remote's url.
   *
   * Returns `None` if the url is not valid utf-8
   */
  url(): string | null
  /**
   * Get the remote's pushurl.
   *
   * Returns `None` if the pushurl is not valid utf-8
   */
  pushurl(): string | null
  /**
   * Get the remote's default branch.
   *
   * The remote (or more exactly its transport) must have connected to the
   * remote repository. This default branch is available as soon as the
   * connection to the remote is initiated and it remains available after
   * disconnecting.
   */
  defaultBranch(): string
  /** Open a connection to a remote. */
  connect(dir: Direction): void
  /** Check whether the remote is connected */
  connected(): boolean
  /** Disconnect from the remote */
  disconnect(): void
  /**
   * Cancel the operation
   *
   * At certain points in its operation, the network code checks whether the
   * operation has been cancelled and if so stops the operation.
   */
  stop(): void
  fetch(refspecs: string[], cb?: (progress: Progress) => void): void
}
export class RemoteCallbacks {
  constructor()
  transferProgress(callback: (...args: any[]) => any): void
  pushTransferProgress(callback: (a: number, b: number, c: number) => void): void
}
export class FetchOptions {
  constructor()
  remoteCallback(callback: RemoteCallbacks): void
}
export class Repository {
  static init(p: string): Repository
  /**
   * Find and open an existing repository, with additional options.
   *
   * If flags contains REPOSITORY_OPEN_NO_SEARCH, the path must point
   * directly to a repository; otherwise, this may point to a subdirectory
   * of a repository, and `open_ext` will search up through parent
   * directories.
   *
   * If flags contains REPOSITORY_OPEN_CROSS_FS, the search through parent
   * directories will not cross a filesystem boundary (detected when the
   * stat st_dev field changes).
   *
   * If flags contains REPOSITORY_OPEN_BARE, force opening the repository as
   * bare even if it isn't, ignoring any working directory, and defer
   * loading the repository configuration for performance.
   *
   * If flags contains REPOSITORY_OPEN_NO_DOTGIT, don't try appending
   * `/.git` to `path`.
   *
   * If flags contains REPOSITORY_OPEN_FROM_ENV, `open_ext` will ignore
   * other flags and `ceiling_dirs`, and respect the same environment
   * variables git does. Note, however, that `path` overrides `$GIT_DIR`; to
   * respect `$GIT_DIR` as well, use `open_from_env`.
   *
   * ceiling_dirs specifies a list of paths that the search through parent
   * directories will stop before entering.  Use the functions in std::env
   * to construct or manipulate such a path list.
   */
  static openExt(path: string, flags: RepositoryOpenFlags, ceilingDirs: Array<string>): Repository
  /**
   * Attempt to open an already-existing repository at or above `path`
   *
   * This starts at `path` and looks up the filesystem hierarchy
   * until it finds a repository.
   */
  static discover(path: string): Repository
  constructor(gitDir: string)
  /** Retrieve and resolve the reference pointed at by HEAD. */
  head(): Reference
  isShallow(): boolean
  isEmpty(): boolean
  isWorktree(): boolean
  /**
   * Returns the path to the `.git` folder for normal repositories or the
   * repository itself for bare repositories.
   */
  path(): string
  /** Returns the current state of this repository */
  state(): RepositoryState
  /**
   * Get the path of the working directory for this repository.
   *
   * If this repository is bare, then `None` is returned.
   */
  workdir(): string | null
  /**
   * Set the path to the working directory for this repository.
   *
   * If `update_link` is true, create/update the gitlink file in the workdir
   * and set config "core.worktree" (if workdir is not the parent of the .git
   * directory).
   */
  setWorkdir(path: string, updateGitlink: boolean): void
  /**
   * Get the currently active namespace for this repository.
   *
   * If there is no namespace, or the namespace is not a valid utf8 string,
   * `None` is returned.
   */
  namespace(): string | null
  /** Set the active namespace for this repository. */
  setNamespace(namespace: string): void
  /** Remove the active namespace for this repository. */
  removeNamespace(): void
  /**
   * Retrieves the Git merge message.
   * Remember to remove the message when finished.
   */
  message(): string
  /** Remove the Git merge message. */
  removeMessage(): void
  /** List all remotes for a given repository */
  remotes(): Array<string>
  /** Get the information for a particular remote */
  remote(name: string): Remote
  /** Lookup a reference to one of the objects in a repository. */
  findTree(oid: string): Tree
  /**
   * Create a diff between a tree and the working directory.
   *
   * The tree you provide will be used for the "old_file" side of the delta,
   * and the working directory will be used for the "new_file" side.
   *
   * This is not the same as `git diff <treeish>` or `git diff-index
   * <treeish>`.  Those commands use information from the index, whereas this
   * function strictly returns the differences between the tree and the files
   * in the working directory, regardless of the state of the index.  Use
   * `tree_to_workdir_with_index` to emulate those commands.
   *
   * To see difference between this and `tree_to_workdir_with_index`,
   * consider the example of a staged file deletion where the file has then
   * been put back into the working dir and further modified.  The
   * tree-to-workdir diff for that file is 'modified', but `git diff` would
   * show status 'deleted' since there is a staged delete.
   *
   * If `None` is passed for `tree`, then an empty tree is used.
   */
  diffTreeToWorkdir(oldTree?: Tree | undefined | null): Diff
  /**
   * Create a diff between a tree and the working directory using index data
   * to account for staged deletes, tracked files, etc.
   *
   * This emulates `git diff <tree>` by diffing the tree to the index and
   * the index to the working directory and blending the results into a
   * single diff that includes staged deleted, etc.
   */
  diffTreeToWorkdirWithIndex(oldTree?: Tree | undefined | null): Diff
  /**
   * Create new commit in the repository
   *
   * If the `update_ref` is not `None`, name of the reference that will be
   * updated to point to this commit. If the reference is not direct, it will
   * be resolved to a direct reference. Use "HEAD" to update the HEAD of the
   * current branch and make it point to this commit. If the reference
   * doesn't exist yet, it will be created. If it does exist, the first
   * parent must be the tip of this branch.
   */
  commit(updateRef: string | undefined | null, author: Signature, committer: Signature, message: string, tree: Tree): string
  getFileLatestModifiedDate(filepath: string): number
  getFileLatestModifiedDateAsync(filepath: string, signal?: AbortSignal | undefined | null): Promise<number>
}
/**
 * A Signature is used to indicate authorship of various actions throughout the
 * library.
 *
 * Signatures contain a name, email, and timestamp. All fields can be specified
 * with `new` while the `now` constructor omits the timestamp. The
 * [`Repository::signature`] method can be used to create a default signature
 * with name and email values read from the configuration.
 *
 * [`Repository::signature`]: struct.Repository.html#method.signature
 */
export class Signature {
  /**
   * Create a new action signature with a timestamp of 'now'.
   *
   * See `new` for more information
   */
  static now(name: string, email: string): Signature
  /**
   * Create a new action signature.
   *
   * The `time` specified is in seconds since the epoch, and the `offset` is
   * the time zone offset in minutes.
   *
   * Returns error if either `name` or `email` contain angle brackets.
   */
  constructor(name: string, email: string, time: number)
  /**
   * Gets the name on the signature.
   *
   * Returns `None` if the name is not valid utf-8
   */
  name(): string | null
  /**
   * Gets the email on the signature.
   *
   * Returns `None` if the email is not valid utf-8
   */
  email(): string | null
  /** Return the time, in seconds, from epoch */
  when(): number
}
export class Tree {
  /** Get the id (SHA1) of a repository object */
  id(): string
}
